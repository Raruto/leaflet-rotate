{"version":3,"file":"leaflet-rotate.js","sources":["../src/dom/DomUtil.js","../src/dom/Draggable.js","../src/geometry/Point.js","../src/layer/DivOverlay.js","../src/layer/Popup.js","../src/layer/Tooltip.js","../src/layer/marker/Icon.js","../src/layer/marker/Marker.js","../src/layer/tile/GridLayer.js","../src/layer/vector/Canvas.js","../src/layer/vector/Renderer.js","../src/layer/vector/SVG.js","../src/map/Map.js","../src/map/handler/CompassBearing.js","../src/map/handler/ContainerMutation.js","../src/map/handler/TouchGestures.js","../src/map/handler/TouchRotate.js","../src/map/handler/ShiftKeyRotate.js","../src/map/handler/TouchZoom.js","../src/control/Rotate.js"],"sourcesContent":["/**\n * L.DomUtil\n */\nconst domUtilProto = L.extend({}, L.DomUtil);\n\nL.extend(L.DomUtil, {\n\n    setTransform: function(el, offset, scale, bearing, pivot) {\n        var pos = offset || new L.Point(0, 0);\n\n        if (!bearing) {\n            offset = pos._round();\n            return domUtilProto.setTransform.call(this, el, offset, scale);\n        }\n\n        pos = pos.rotateFrom(bearing, pivot);\n\n        el.style[L.DomUtil.TRANSFORM] =\n            'translate3d(' + pos.x + 'px,' + pos.y + 'px' + ',0)' +\n            (scale ? ' scale(' + scale + ')' : '') +\n            ' rotate(' + bearing + 'rad)';\n    },\n\n    setPosition: function(el, point, bearing, pivot) { // (HTMLElement, Point[, Boolean])\n        if (!bearing) {\n            return domUtilProto.setPosition.call(this, el, point);\n        }\n\n        /*eslint-disable */\n        el._leaflet_pos = point;\n        /*eslint-enable */\n\n        if (L.Browser.any3d) {\n            L.DomUtil.setTransform(el, point, undefined, bearing, pivot);\n        } else {\n            el.style.left = point.x + 'px';\n            el.style.top = point.y + 'px';\n        }\n    },\n\n    // Constants for rotation\n    DEG_TO_RAD: Math.PI / 180,\n    RAD_TO_DEG: 180 / Math.PI,\n\n});\n","/**\n * L.Draggable\n */\nL.Draggable.include({\n\n    updateMapBearing: function(mapBearing) {\n        this._mapBearing = mapBearing;\n    },\n\n});\n","/**\n * L.Point\n */\nL.extend(L.Point.prototype, {\n\n    // Rotate around (0,0) by applying the 2D rotation matrix:\n    // ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤\n    // ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦\n    // Theta must be given in radians.\n    rotate: function(theta) {\n        if (!theta) { return this; }\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n\n        return new L.Point(\n            this.x * cosTheta - this.y * sinTheta,\n            this.x * sinTheta + this.y * cosTheta\n        );\n    },\n\n    // Rotate around (pivot.x, pivot.y) by:\n    // 1. subtract (pivot.x, pivot.y)\n    // 2. rotate around (0, 0)\n    // 3. add (pivot.x, pivot.y) back\n    // same as `this.subtract(pivot).rotate(theta).add(pivot)`\n    rotateFrom: function(theta, pivot) {\n        if (!theta) { return this; }\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        var cx = pivot.x,\n            cy = pivot.y;\n        var x = this.x - cx,\n            y = this.y - cy;\n\n        return new L.Point(\n            x * cosTheta - y * sinTheta + cx,\n            x * sinTheta + y * cosTheta + cy\n        );\n    },\n\n});\n","/**\n * L.DivOverlay\n */\nconst divOverlayProto = L.extend({}, L.DivOverlay.prototype);\n\nL.DivOverlay.include({\n\n    getEvents: function() {\n        return L.extend(divOverlayProto.getEvents.call(this), { rotate: this._updatePosition });\n    },\n\n    _updatePosition: function() {\n        if (!this._map) { return; }\n\n        var pos = this._map.latLngToLayerPoint(this._latlng),\n            offset = L.point(this.options.offset),\n            anchor = this._getAnchor();\n\n        if (this._zoomAnimated) {\n            // TODO: use divOverlayProto._updatePosition\n            if (this._map._rotate) {\n                pos = this._map.rotatedPointToMapPanePoint(pos);\n            }\n            L.DomUtil.setPosition(this._container, pos.add(anchor));\n        } else {\n            offset = offset.add(pos).add(anchor);\n        }\n\n        var bottom = this._containerBottom = -offset.y,\n            left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;\n\n        // bottom position the popup in case the height of the popup changes (images loading etc)\n        this._container.style.bottom = bottom + 'px';\n        this._container.style.left = left + 'px';\n    },\n\n});\n","/**\n * L.Popup\n */\nconst popupProto = L.extend({}, L.Popup.prototype);\n\nL.Popup.include({\n\n    _animateZoom: function(e) {\n        if (!this._map._rotate) {\n            popupProto._animateZoom.call(this, e);\n        }\n        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),\n            anchor = this._getAnchor();\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n\n        L.DomUtil.setPosition(this._container, pos.add(anchor));\n    },\n\n    _adjustPan: function() {\n        if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\n\n        // We can endlessly recurse if keepInView is set and the view resets.\n        // Let's guard against that by exiting early if we're responding to our own autopan.\n        if (this._autopanning) {\n            this._autopanning = false;\n            return;\n        }\n\n        var map = this._map,\n            marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,\n            containerHeight = this._container.offsetHeight + marginBottom,\n            containerWidth = this._containerWidth,\n            layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n        layerPos._add(L.DomUtil.getPosition(this._container));\n\n        // var containerPos = map.layerPointToContainerPoint(layerPos);\n        // TODO: use popupProto._adjustPan\n        var containerPos = layerPos._add(this._map._getMapPanePos()),\n            padding = L.point(this.options.autoPanPadding),\n            paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\n            paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\n            size = map.getSize(),\n            dx = 0,\n            dy = 0;\n\n        if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\n            dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n        }\n        if (containerPos.x - dx - paddingTL.x < 0) { // left\n            dx = containerPos.x - paddingTL.x;\n        }\n        if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\n            dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n        }\n        if (containerPos.y - dy - paddingTL.y < 0) { // top\n            dy = containerPos.y - paddingTL.y;\n        }\n\n        // @namespace Map\n        // @section Popup events\n        // @event autopanstart: Event\n        // Fired when the map starts autopanning when opening a popup.\n        if (dx || dy) {\n            // Track that we're autopanning, as this function will be re-ran on moveend\n            if (this.options.keepInView) {\n                this._autopanning = true;\n            }\n            map\n                .fire('autopanstart')\n                .panBy([dx, dy]);\n        }\n    },\n\n});\n","/**\n * L.Tooltip\n */\nconst tooltipProto = L.extend({}, L.Tooltip.prototype);\n\nL.Tooltip.include({\n\n    _updatePosition: function() {\n        if (!this._map._rotate) {\n            return tooltipProto._updatePosition.call(this);\n        }\n        var pos = this._map.latLngToLayerPoint(this._latlng);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n    _animateZoom: function(e) {\n        if (!this._map._rotate) {\n            return tooltipProto._animateZoom.call(this, e);\n        }\n        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n});\n","/**\n * L.Icon\n */\nconst iconProto = L.extend({}, L.Icon.prototype);\n\nL.Icon.include({\n\n    _setIconStyles: function(img, name) {\n        var options = this.options;\n        var sizeOption = options[name + 'Size'];\n\n        if (typeof sizeOption === 'number') {\n            sizeOption = [sizeOption, sizeOption];\n        }\n\n        var size = L.point(sizeOption),\n            anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\n                size && size.divideBy(2, true));\n\n        img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n        if (anchor) {\n            img.style.marginLeft = (-anchor.x) + 'px';\n            img.style.marginTop = (-anchor.y) + 'px';\n            // TODO: use iconProto._setIconStyles\n            img.style[L.DomUtil.TRANSFORM + \"Origin\"] = anchor.x + \"px \" + anchor.y + \"px 0px\";\n        }\n\n        if (size) {\n            img.style.width = size.x + 'px';\n            img.style.height = size.y + 'px';\n        }\n    },\n\n});\n","/**\n * L.Handler.MarkerDrag\n */\nvar markerDragProto;\n\nvar MarkerDrag = {\n\n    _onDragStart: function() {\n        if (!this._marker._map._rotate) {\n            return markerDragProto._onDragStart.call(this)\n        }\n        this._draggable.updateMapBearing(this._marker._map._bearing);\n    },\n\n    _onDrag: function(e) {\n        var marker = this._marker,\n            // TODO: use markerDragProto._onDrag\n            rotated_marker = marker.options.rotation || marker.options.rotateWithView,\n            shadow = marker._shadow,\n            iconPos = L.DomUtil.getPosition(marker._icon);\n\n        // TODO: use markerDragProto._onDrag\n        // update shadow position\n        if (!rotated_marker && shadow) {\n            L.DomUtil.setPosition(shadow, iconPos);\n        }\n\n        // TODO: use markerDragProto._onDrag\n        if (marker._map._rotate) {\n            // Reverse calculation from mapPane coordinates to rotatePane coordinates\n            iconPos = marker._map.mapPanePointToRotatedPoint(iconPos);\n        }\n        var latlng = marker._map.layerPointToLatLng(iconPos);\n\n        marker._latlng = latlng;\n        e.latlng = latlng;\n        e.oldLatLng = this._oldLatLng;\n\n        // TODO: use markerDragProto._onDrag\n        if (rotated_marker) marker.setLatLng(latlng); // use `setLatLng` to presisit rotation. low efficiency\n        else marker.fire('move', e); // `setLatLng` will trig 'move' event. we imitate here.\n\n        // @event drag: Event\n        // Fired repeatedly while the user drags the marker.\n        marker\n            .fire('drag', e);\n    },\n\n    _onDragEnd: function(e) {\n        if (this._marker._map._rotate) {\n            this._marker.update();\n        }\n        markerDragProto._onDragEnd.call(this, e);\n    },\n\n};\n\n/**\n * L.Marker\n */\nconst markerProto = L.extend({}, L.Marker.prototype);\n\nL.Marker.mergeOptions({\n\n    // @option rotation: Number = 0\n    // Rotation of this marker in rad\n    rotation: 0,\n\n    // @option rotateWithView: Boolean = false\n    // Rotate this marker when map rotates\n    rotateWithView: false,\n\n});\n\nL.Marker.include({\n\n    getEvents: function() {\n        return L.extend(markerProto.getEvents.call(this), { rotate: this.update });\n    },\n\n    onAdd: function(map) {\n        markerProto.onAdd.call(this, map);\n        map.on('rotate', this.update, this);\n    },\n\n    _initInteraction: function() {\n        var ret = markerProto._initInteraction.call(this);\n        if (this.dragging && this.dragging.enabled() && this._map && this._map._rotate) {\n            // L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable\n            markerDragProto = markerDragProto || Object.getPrototypeOf(this.dragging);\n            Object.assign(this.dragging, {\n                _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),\n                _onDrag: MarkerDrag._onDrag.bind(this.dragging),\n                _onDragEnd: MarkerDrag._onDragEnd.bind(this.dragging),\n            })\n            this.dragging.disable();\n            this.dragging.enable();\n        }\n        return ret;\n    },\n\n    _setPos: function(pos) {\n\n        // TODO: use markerProto._setPos\n        if (this._map._rotate) {\n            pos = this._map.rotatedPointToMapPanePoint(pos);\n        }\n\n        // TODO: use markerProto._setPos\n        var bearing = this.options.rotation || 0;\n        if (this.options.rotateWithView) {\n            bearing += this._map._bearing;\n        }\n\n        // TODO: use markerProto._setPos\n        if (this._icon) {\n            L.DomUtil.setPosition(this._icon, pos, bearing, pos);\n        }\n\n        // TODO: use markerProto._setPos\n        if (this._shadow) {\n            L.DomUtil.setPosition(this._shadow, pos, bearing, pos);\n        }\n\n        this._zIndex = pos.y + this.options.zIndexOffset;\n\n        this._resetZIndex();\n    },\n\n    /**\n     * @since leaflet@v1.8\n     * @see https://github.com/Leaflet/Leaflet/commit/4f639a85efffa49c3e64a07dc0b6f5aa73f13449\n     */\n    _panOnFocus: function () {\n        /**\n         * Temporary disable this for fix: https://github.com/Raruto/leaflet-rotate/issues/18\n         * \n         * @TODO restore it and support for `L.Marker::autoPanOnFocus` option\n         */\n\n        // var map = this._map;\n        // if (!map) { return; }\n\n        // var iconOpts = this.options.icon.options;\n        // var size = iconOpts.iconSize ? L.point(iconOpts.iconSize) : L.point(0, 0);\n        // var anchor = iconOpts.iconAnchor ? L.point(iconOpts.iconAnchor) : L.point(0, 0);\n\n        // map.panInside(this._latlng, {\n        //     paddingTopLeft: anchor,\n        //     paddingBottomRight: size.subtract(anchor)\n        // });\n    },\n\n    _updateZIndex: function(offset) {\n        if (!this._map._rotate) {\n            return markerProto._updateZIndex.call(this, offset)\n        }\n        this._icon.style.zIndex = Math.round(this._zIndex + offset);\n    },\n\n    setRotation: function(rotation) {\n        this.options.rotation = rotation;\n        this.update();\n    },\n\n});\n","/**\n * L.GridLayer\n */\nconst gridLayerProto = L.extend({}, L.GridLayer.prototype);\n\nL.GridLayer.include({\n\n    getEvents: function() {\n        var events = gridLayerProto.getEvents.call(this);\n        if (this._map._rotate && !this.options.updateWhenIdle) {\n            if (!this._onRotate) {\n                this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n            }\n            events.rotate = this._onRotate;\n        }\n        return events;\n    },\n\n    _getTiledPixelBounds: function(center) {\n        if (!this._map._rotate) {\n            return gridLayerProto._getTiledPixelBounds.call(this, center);\n        }\n\n        var map = this._map,\n            mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),\n            scale = map.getZoomScale(mapZoom, this._tileZoom),\n            pixelCenter = map.project(center, this._tileZoom).floor(),\n            size = map.getSize(),\n            halfSize = new L.Bounds([\n                map.containerPointToLayerPoint([0, 0]).floor(),\n                map.containerPointToLayerPoint([size.x, 0]).floor(),\n                map.containerPointToLayerPoint([0, size.y]).floor(),\n                map.containerPointToLayerPoint([size.x, size.y]).floor()\n            ]).getSize().divideBy(scale * 2);\n\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n\n});\n","/**\n * L.Canvas\n */\nconst canvasProto = L.extend({}, L.Canvas.prototype);\n\nL.Canvas.include({\n\n    onAdd: function() {\n        canvasProto.onAdd.call(this);\n        // When rotating the canvas itself, it is cleared by some weird reason, so redraw.\n        this._map.on('rotate', this._redraw, this);\n    },\n\n    onRemove: function() {\n        canvasProto.onRemove.call(this);\n        this._map.off('rotate', this._redraw, this);\n    },\n\n    _update: function() {\n        canvasProto._update.call(this);\n        // Tell paths to redraw themselves\n        this.fire('update')\n    },\n\n});\n","/**\n * L.Renderer\n */\nconst rendererProto = L.extend({}, L.Renderer.prototype);\n\nL.Renderer.include({\n\n    onAdd: function() {\n        rendererProto.onAdd.call(this);\n        // this._map.on('rotate', this._update, this);\n    },\n\n    onRemove: function() {\n        rendererProto.onRemove.call(this);\n        // this._map.off('rotate', this._update, this);\n    },\n\n    /**\n     * @TODO rechek this changes from leaflet@v1.9.3\n     * \n     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3\n     */\n    _updateTransform: function(center, zoom) {\n        if (!this._map._rotate) {\n            return rendererProto._updateTransform.call(this, center, zoom);\n        }\n        var scale = this._map.getZoomScale(zoom, this._zoom),\n            offset = this._map._latLngToNewLayerPoint(this._topLeft, zoom, center);\n        if (L.Browser.any3d) {\n            L.DomUtil.setTransform(this._container, offset, scale);\n        } else {\n            L.DomUtil.setPosition(this._container, offset);\n        }\n    },\n\n    _update: function() {\n        if (!this._map._rotate) {\n            return rendererProto._update.call(this);\n        }\n        // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n        // Subclasses are responsible of firing the 'update' event.\n        var p = this.options.padding,\n            map = this._map,\n            size = this._map.getSize(),\n            padMin = size.multiplyBy(-p),\n            padMax = size.multiplyBy(1 + p),\n            //// TODO: Somehow refactor this out into map.something() - the code is\n            ////   pretty much the same as in GridLayer.\n            clip = new L.Bounds([\n                map.containerPointToLayerPoint([padMin.x, padMin.y]).floor(),\n                map.containerPointToLayerPoint([padMin.x, padMax.y]).floor(),\n                map.containerPointToLayerPoint([padMax.x, padMin.y]).floor(),\n                map.containerPointToLayerPoint([padMax.x, padMax.y]).floor()\n            ]);\n        //min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n        this._bounds = clip;\n        // this._topLeft = clip.min;\n        this._topLeft = this._map.layerPointToLatLng(clip.min);\n\n        this._center = this._map.getCenter();\n        this._zoom = this._map.getZoom();\n    },\n\n});\n","/**\n * L.SVG\n */\nconst svgProto = L.extend({}, L.SVG.prototype);\n\nL.SVG.include({\n\n    _update: function() {\n        svgProto._update.call(this);\n        if (this._map._rotate) {\n            this.fire('update');\n        }\n    },\n\n});\n","/**\n * L.Map\n */\nconst mapProto = L.extend({}, L.Map.prototype);\n\nL.Map.mergeOptions({ rotate: false, bearing: 0, });\n\n/**\n * @TODO rechek this changes from leaflet@v1.9.3\n * \n * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3\n */\nL.Map.include({\n\n    initialize: function(id, options) { // (HTMLElement or String, Object)\n        if (options.rotate) {\n            this._rotate = true;\n            this._bearing = 0;\n        }\n        mapProto.initialize.call(this, id, options);\n        if(this.options.rotate){\n          this.setBearing(this.options.bearing);\n        }\n    },\n\n    // createPane: function(name, container) {\n    //     if (!this._rotate || name == 'mapPane') {\n    //         return mapProto.createPane.call(this, name, container);\n    //     }\n    //     // init \"rotatePane\"\n    //     if (!this._rotatePane) {\n    //         // this._pivot = this.getSize().divideBy(2);\n    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);\n    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);\n    //     }\n    //     return mapProto.createPane.call(this, name, container || this._rotatePane);\n    // },\n\n    containerPointToLayerPoint: function(point) { // (Point)\n        if (!this._rotate) {\n            return mapProto.containerPointToLayerPoint.call(this, point);\n        }\n        return L.point(point)\n            .subtract(this._getMapPanePos())\n            .rotateFrom(-this._bearing, this._getRotatePanePos())\n            .subtract(this._getRotatePanePos());\n    },\n\n    getBounds: function() {\n        if (!this._rotate) {\n            return mapProto.getBounds.call(this);\n        }\n        var size = this.getSize();\n        var topleft = this.layerPointToLatLng(this.containerPointToLayerPoint([0, 0])),\n            topright = this.layerPointToLatLng(this.containerPointToLayerPoint([size.x, 0])),\n            bottomright = this.layerPointToLatLng(this.containerPointToLayerPoint([size.x, size.y])),\n            bottomleft = this.layerPointToLatLng(this.containerPointToLayerPoint([0, size.y]));\n\n        // Use LatLngBounds' build-in constructor that automatically extends the bounds to fit the passed points\n        return new L.LatLngBounds([topleft, topright, bottomright, bottomleft]);\n    },\n\n    layerPointToContainerPoint: function(point) { // (Point)\n        if (!this._rotate) {\n            return mapProto.layerPointToContainerPoint.call(this, point);\n        }\n        return L.point(point)\n            .add(this._getRotatePanePos())\n            .rotateFrom(this._bearing, this._getRotatePanePos())\n            .add(this._getMapPanePos());\n    },\n\n    // Rotation methods\n    // setBearing will work with just the 'theta' parameter.\n    setBearing: function(theta) {\n        if (!L.Browser.any3d || !this._rotate) { return; }\n\n        var rotatePanePos = this._getRotatePanePos();\n        var halfSize = this.getSize().divideBy(2);\n        this._pivot = this._getMapPanePos().clone().multiplyBy(-1).add(halfSize);\n\n        rotatePanePos = rotatePanePos.rotateFrom(-this._bearing, this._pivot);\n\n        this._bearing = theta * L.DomUtil.DEG_TO_RAD; // TODO: mod 360\n        this._rotatePanePos = rotatePanePos.rotateFrom(this._bearing, this._pivot);\n\n        L.DomUtil.setPosition(this._rotatePane, rotatePanePos, this._bearing, this._pivot);\n\n        this.fire('rotate');\n    },\n\n    getBearing: function() {\n        return this._bearing * L.DomUtil.RAD_TO_DEG;\n    },\n\n    _initPanes: function() {\n        var panes = this._panes = {};\n        this._paneRenderers = {};\n\n        // @section\n        //\n        // Panes are DOM elements used to control the ordering of layers on the map. You\n        // can access panes with [`map.getPane`](#map-getpane) or\n        // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the\n        // [`map.createPane`](#map-createpane) method.\n        //\n        // Every map has the following default panes that differ only in zIndex.\n        //\n        // @pane mapPane: HTMLElement = 'auto'\n        // Pane that contains all other map panes\n\n        this._mapPane = this.createPane('mapPane', this._container);\n        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\n\n        if (this._rotate) {\n            this._rotatePane = this.createPane('rotatePane', this._mapPane);\n            this._norotatePane = this.createPane('norotatePane', this._mapPane);\n\n            // @pane tilePane: HTMLElement = 2\n            // Pane for tile layers\n            this.createPane('tilePane', this._rotatePane);\n            // @pane overlayPane: HTMLElement = 4\n            // Pane for overlays like polylines and polygons\n            this.createPane('overlayPane', this._rotatePane);\n\n            // @pane shadowPane: HTMLElement = 5\n            // Pane for overlay shadows (e.g. marker shadows)\n            this.createPane('shadowPane', this._norotatePane);\n            // @pane markerPane: HTMLElement = 6\n            // Pane for marker icons\n            this.createPane('markerPane', this._norotatePane);\n            // @pane tooltipPane: HTMLElement = 650\n            // Pane for tooltips.\n            this.createPane('tooltipPane', this._norotatePane);\n            // @pane popupPane: HTMLElement = 700\n            // Pane for popups.\n            this.createPane('popupPane', this._norotatePane);\n        } else {\n            // @pane tilePane: HTMLElement = 2\n            // Pane for tile layers\n            this.createPane('tilePane');\n            // @pane overlayPane: HTMLElement = 4\n            // Pane for overlays like polylines and polygons\n            this.createPane('overlayPane');\n            // @pane shadowPane: HTMLElement = 5\n            // Pane for overlay shadows (e.g. marker shadows)\n            this.createPane('shadowPane');\n            // @pane markerPane: HTMLElement = 6\n            // Pane for marker icons\n            this.createPane('markerPane');\n            // @pane tooltipPane: HTMLElement = 650\n            // Pane for tooltips.\n            this.createPane('tooltipPane');\n            // @pane popupPane: HTMLElement = 700\n            // Pane for popups.\n            this.createPane('popupPane');\n        }\n\n        if (!this.options.markerZoomAnimation) {\n            L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\n            L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\n        }\n    },\n\n    // @method rotatedPointToMapPanePoint(point: Point): Point\n    // Converts a coordinate from the rotated pane reference system\n    // to the reference system of the not rotated map pane.\n    rotatedPointToMapPanePoint: function(point) {\n        return L.point(point).rotate(this._bearing)._add(this._getRotatePanePos());\n    },\n\n    // @method mapPanePointToRotatedPoint(point: Point): Point\n    // Converts a coordinate from the not rotated map pane reference system\n    // to the reference system of the rotated pane.\n    mapPanePointToRotatedPoint: function(point) {\n        return L.point(point)._subtract(this._getRotatePanePos()).rotate(-this._bearing);\n    },\n\n    // offset of the specified place to the current center in pixels\n    _getCenterOffset: function(latlng) {\n        var centerOffset = mapProto._getCenterOffset.call(this, latlng);\n        if (this._rotate) {\n            centerOffset = centerOffset.rotate(this._bearing);\n        }\n        return centerOffset;\n    },\n\n    _getRotatePanePos: function() {\n        return this._rotatePanePos || new L.Point(0, 0);\n    },\n\n    _getNewPixelOrigin: function(center, zoom) {\n        var viewHalf = this.getSize()._divideBy(2);\n        if (!this._rotate) {\n            mapProto._getNewPixelOrigin.call(this, center, zoom);\n        }\n        return this.project(center, zoom)\n            .rotate(this._bearing)\n            ._subtract(viewHalf)\n            ._add(this._getMapPanePos())\n            ._add(this._getRotatePanePos())\n            .rotate(-this._bearing)\n            ._round();\n    },\n\n    _handleGeolocationResponse: function(pos) {\n        if (!this._container._leaflet_id) { return; }\n\n        var lat = pos.coords.latitude,\n            lng = pos.coords.longitude,\n            // TODO: use mapProto._handleGeolocationResponse\n            hdg = pos.coords.heading,\n            latlng = new L.LatLng(lat, lng),\n            bounds = latlng.toBounds(pos.coords.accuracy),\n            options = this._locateOptions;\n\n        if (options.setView) {\n            var zoom = this.getBoundsZoom(bounds);\n            this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n        }\n\n        var data = {\n            latlng: latlng,\n            bounds: bounds,\n            timestamp: pos.timestamp,\n            // TODO: use mapProto._handleGeolocationResponse\n            heading: hdg\n        };\n\n        for (var i in pos.coords) {\n            if (typeof pos.coords[i] === 'number') {\n                data[i] = pos.coords[i];\n            }\n        }\n\n        // @event locationfound: LocationEvent\n        // Fired when geolocation (using the [`locate`](#map-locate) method)\n        // went successfully.\n        this.fire('locationfound', data);\n    },\n\n});\n","/*\n * L.Map.CompassBearing will rotate the map according to a smartphone's compass.\n */\n\nL.Map.CompassBearing = L.Handler.extend({\n\n    initialize: function(map) {\n        if (!window.DeviceOrientationEvent) {\n            this._capable = false;\n            return;\n        }\n        this._capable = true;\n        this._map = map;\n\n        this._throttled = L.Util.throttle(this._onDeviceOrientation, 1000, this);\n    },\n\n    addHooks: function() {\n        if (this._capable && this._map._rotate) {\n            L.DomEvent.on(window, 'deviceorientation', this._throttled, this);\n        }\n    },\n\n    removeHooks: function() {\n        if (this._capable && this._map._rotate) {\n            L.DomEvent.off(window, 'deviceorientation', this._throttled, this);\n        }\n    },\n\n    _onDeviceOrientation: function(event) {\n        if (event.alpha !== null) {\n            this._map.setBearing(event.alpha - window.orientation);\n        }\n    },\n\n});\n\n// @section Handlers\n// @property compassBearing: Handler\n// Compass bearing handler.\nL.Map.addInitHook('addHandler', 'compassBearing', L.Map.CompassBearing);\n","/*\n * L.Handler.ContainerMutation triggers `invalidateResize` when the map's DOM container mutates.\n */\n\n// @namespace Map\n// @section Interaction Options\nL.Map.mergeOptions({\n\n    // @option trackContainerMutation: Boolean = false\n    // Whether the map uses [mutation observers](https://developer.mozilla.org/docs/Web/API/MutationObserver)\n    // to detect changes in its container and trigger `invalidateSize`. Disabled\n    // by default due to support not being available in all web browsers.\n    trackContainerMutation: false\n\n});\n\nL.Map.ContainerMutation = L.Handler.extend({\n\n    addHooks: function() {\n        if (!L.Browser.mutation) {\n            return;\n        }\n\n        if (!this._observer) {\n            this._observer = new MutationObserver(L.Util.bind(this._onMutation, this));\n        }\n\n        this._observer.observe(this._map.getContainer(), {\n            childList: false,\n            attributes: true,\n            characterData: false,\n            subtree: false,\n            attributeFilter: ['style']\n        });\n    },\n\n    removeHooks: function() {\n        if (!L.Browser.mutation) {\n            return;\n        }\n        this._observer.disconnect();\n    },\n\n    _onMutation: function() {\n        this._map.invalidateSize();\n    },\n\n});\n\n// @section Handlers\n// @property containerMutation: Handler\n// Container mutation handler (disabled unless [`trackContainerMutation`](#map-trackcontainermutation) is set).\nL.Map.addInitHook('addHandler', 'trackContainerMutation', L.Map.ContainerMutation);\n","/*\n * L.Handler.TouchGestures is both TouchZoom plus TouchRotate.\n */\n\n// @namespace Map\n// @section Interaction Options\nL.Map.mergeOptions({\n\n    // @option bounceAtZoomLimits: Boolean = true\n    // Set it to false if you don't want the map to zoom beyond min/max zoom\n    // and then bounce back when pinch-zooming.\n    bounceAtZoomLimits: true,\n\n});\n\nL.Map.TouchGestures = L.Handler.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this.rotate = !!this._map.options.touchRotate;\n        this.zoom = !!this._map.options.touchZoom;\n    },\n\n    addHooks: function() {\n        L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n\n    removeHooks: function() {\n        L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n\n    _onTouchStart: function(e) {\n        var map = this._map;\n\n        if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming || this._rotating) { return; }\n\n        var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n            p2 = map.mouseEventToContainerPoint(e.touches[1]),\n            vector = p1.subtract(p2);\n\n        this._centerPoint = map.getSize()._divideBy(2);\n        this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n\n        if (this.zoom) {\n            if (map.options.touchZoom !== 'center') {\n                this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n            }\n            this._startDist = p1.distanceTo(p2);\n            this._startZoom = map.getZoom();\n            this._zooming = true;\n        } else {\n            this._zooming = false;\n        }\n\n        if (this.rotate) {\n            this._startTheta = Math.atan(vector.x / vector.y);\n            this._startBearing = map.getBearing();\n            if (vector.y < 0) { this._startBearing += 180; }\n            this._rotating = true;\n        } else {\n            this._rotating = false;\n        }\n\n        this._moved = false;\n\n        map.stop();\n\n        L.DomEvent\n            .on(document, 'touchmove', this._onTouchMove, this)\n            .on(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n        L.DomEvent.preventDefault(e);\n    },\n\n    _onTouchMove: function(e) {\n        if (!e.touches || e.touches.length !== 2 || !(this._zooming || this._rotating)) { return; }\n\n        var map = this._map,\n            p1 = map.mouseEventToContainerPoint(e.touches[0]),\n            p2 = map.mouseEventToContainerPoint(e.touches[1]),\n            vector = p1.subtract(p2),\n            scale = p1.distanceTo(p2) / this._startDist,\n            delta;\n\n        if (this._rotating) {\n            var theta = Math.atan(vector.x / vector.y);\n            var bearingDelta = (theta - this._startTheta) * L.DomUtil.RAD_TO_DEG;\n            if (vector.y < 0) { bearingDelta += 180; }\n            if (bearingDelta) {\n                /// TODO: The pivot should be the last touch point, but zoomAnimation manages to\n                ///   overwrite the rotate pane position. Maybe related to #3529.\n                map.setBearing(this._startBearing - bearingDelta);\n            }\n        }\n\n        if (this._zooming) {\n            this._zoom = map.getScaleZoom(scale, this._startZoom);\n\n            if (!map.options.bounceAtZoomLimits && (\n                    (this._zoom < map.getMinZoom() && scale < 1) ||\n                    (this._zoom > map.getMaxZoom() && scale > 1))) {\n                this._zoom = map._limitZoom(this._zoom);\n            }\n\n            if (map.options.touchZoom === 'center') {\n                this._center = this._startLatLng;\n                if (scale === 1) { return; }\n            } else {\n                // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n                delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n                if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n\n                var alpha = -map.getBearing() * L.DomUtil.DEG_TO_RAD;\n\n                this._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta.rotate(alpha)));\n            }\n\n        }\n\n        if (!this._moved) {\n            map._moveStart(true);\n            this._moved = true;\n        }\n\n        L.Util.cancelAnimFrame(this._animRequest);\n\n        var moveFn = L.bind(map._move, map, this._center, this._zoom, { pinch: true, round: false }, undefined);\n        this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);\n\n        L.DomEvent.preventDefault(e);\n    },\n\n    _onTouchEnd: function() {\n        if (!this._moved || !this._zooming) {\n            this._zooming = false;\n            return;\n        }\n\n        this._zooming = false;\n        this._rotating = false;\n        L.Util.cancelAnimFrame(this._animRequest);\n\n        L.DomEvent\n            .off(document, 'touchmove', this._onTouchMove)\n            .off(document, 'touchend touchcancel', this._onTouchEnd);\n\n        if (this.zoom) {\n            // Pinch updates GridLayers' levels only when snapZoom is off, so snapZoom becomes noUpdate.\n            if (this._map.options.zoomAnimation) {\n                this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.snapZoom);\n            } else {\n                this._map._resetView(this._center, this._map._limitZoom(this._zoom));\n            }\n        }\n    },\n\n});\n\n// @section Handlers\n// @property touchGestures: Handler\n// Touch gestures handler.\nL.Map.addInitHook('addHandler', 'touchGestures', L.Map.TouchGestures);\n","/*\n * L.Handler.TouchRotate is used by L.Map to add two-finger rotation gestures.\n */\n\n// @namespace Map\n// @section Interaction Options\nL.Map.mergeOptions({\n\n    // @section Touch interaction options\n    // @option touchRotate: Boolean|String = *\n    // Whether the map can be rotated with a two-finger rotation gesture\n    touchRotate: false,\n\n});\n\nL.Map.TouchRotate = L.Handler.extend({\n\n    addHooks: function() {\n        this._map.touchGestures.enable();\n        this._map.touchGestures.rotate = true;\n    },\n\n    removeHooks: function() {\n        this._map.touchGestures.rotate = false;\n    },\n\n});\n\n// @section Handlers\n// @property touchZoom: Handler\n// Touch rotate handler.\nL.Map.addInitHook('addHandler', 'touchRotate', L.Map.TouchRotate);\n","/*\n * L.Handler.ShiftKeyRotate is used by L.Map to add shift-wheel rotation.\n */\n\n// @namespace Map\n// @section Interaction Options\nL.Map.mergeOptions({\n\n    // @section ShiftKey interaction options\n    // @option shiftKeyRotate: Boolean|String = *\n    // Whether the map can be rotated with a shit-wheel rotation\n    shiftKeyRotate: true,\n\n});\n\nL.Map.ShiftKeyRotate = L.Handler.extend({\n\n    addHooks: function() {\n        L.DomEvent.on(this._map._container, \"wheel\", this._handleShiftScroll, this);\n        // this._map.shiftKeyRotate.enable();\n        this._map.shiftKeyRotate.rotate = true;\n    },\n\n    removeHooks: function() {\n        L.DomEvent.off(this._map._container, \"wheel\", this._handleShiftScroll, this);\n        this._map.shiftKeyRotate.rotate = false;\n    },\n\n    _handleShiftScroll: function(e) {\n        if (e.shiftKey) {\n            e.preventDefault();\n            this._map.scrollWheelZoom.disable();\n            this._map.setBearing((this._map._bearing * L.DomUtil.RAD_TO_DEG) + Math.sign(e.deltaY) * 5);\n        } else {\n            this._map.scrollWheelZoom.enable();\n        }\n    },\n\n});\n\n// @section Handlers\n// @property touchZoom: Handler\n// Touch rotate handler.\nL.Map.addInitHook('addHandler', 'shiftKeyRotate', L.Map.ShiftKeyRotate);\n\n// decrease \"scrollWheelZoom\" handler priority over \"shiftKeyRotate\" handler\nL.Map.addInitHook(function() {\n    if (this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled()) {\n        this.scrollWheelZoom.disable();\n        this.scrollWheelZoom.enable();\n    }\n});\n","/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\n// @namespace Map\n// @section Interaction Options\nL.Map.mergeOptions({\n\n    // @section Touch interaction options\n    // @option touchZoom: Boolean|String = *\n    // Whether the map can be zoomed by touch-dragging with two fingers. If\n    // passed `'center'`, it will zoom to the center of the view regardless of\n    // where the touch events (fingers) were. Enabled for touch-capable web\n    // browsers except for old Androids.\n    touchZoom: L.Browser.touch && !L.Browser.android23,\n\n    bounceAtZoomLimits: false,\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\n    addHooks: function() {\n        L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');\n        this._map.touchGestures.enable();\n        this._map.touchGestures.zoom = true;\n    },\n\n    removeHooks: function() {\n        L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');\n        this._map.touchGestures.zoom = false;\n    },\n\n});\n\n// @section Handlers\n// @property touchZoom: Handler\n// Touch zoom handler.\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n","/**\n * L.Control.Rotate\n */\n\n// A tri-state control for map rotation. States are:\n// Locked (default)\n// Unlocked (user can pinch-rotate)\n// Follow (rotation follows device orientation, if available)\nL.Control.Rotate = L.Control.extend({\n\n    options: {\n        position: 'topleft',\n        closeOnZeroBearing: true\n    },\n\n    onAdd: function(map) {\n        this._onDeviceOrientation = L.Util.throttle(this._unthrottledOnDeviceOrientation, 100, this);\n\n        var container = this._container = L.DomUtil.create('div', 'leaflet-control-rotate leaflet-bar');\n\n        // this.button = L.Control.Zoom.prototype._createButton.call(this, 'R', 'leaflet-control-rotate', 'leaflet-control-rotate', container, this._toggleLock);\n\n        var arrow = this._arrow = L.DomUtil.create('span', 'leaflet-control-rotate-arrow');\n\n        arrow.style.backgroundImage = `url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")`;\n        arrow.style.cursor = 'grab';\n        arrow.style.display = 'block';\n        arrow.style.width = '100%';\n        arrow.style.height = '100%';\n        arrow.style.backgroundRepeat = 'no-repeat';\n        arrow.style.backgroundPosition = '50%';\n\n        // Copy-pasted from L.Control.Zoom\n        var link = this._link = L.DomUtil.create('a', 'leaflet-control-rotate-toggle', container);\n        link.appendChild(arrow);\n        link.href = '#';\n        link.title = 'Rotate map';\n        // link.draggable = false;\n\n        L.DomEvent\n            .on(link, 'dblclick', L.DomEvent.stopPropagation)\n            .on(link, 'mousedown', this._handleMouseDown, this)\n            .on(link, 'click', L.DomEvent.stop)\n            .on(link, 'click', this._cycleState, this)\n            .on(link, 'click', this._refocusOnMap, this);\n\n        if (!L.Browser.any3d) {\n            L.DomUtil.addClass(link, 'leaflet-disabled');\n        }\n\n        this._restyle();\n\n        map.on('rotate', this._restyle.bind(this));\n\n        // State flag\n        this._follow = false;\n        this._canFollow = false;\n\n        if (this.options.closeOnZeroBearing && map.getBearing() === 0) {\n            container.style.display = 'none';\n        }\n\n        return container;\n    },\n\n    _handleMouseDown: function(e) {\n        L.DomEvent.stop(e); // L.DomEvent.stopPropagation(e);\n        this.dragging = true;\n        this.dragstartX = e.pageX;\n        this.dragstartY = e.pageY;\n        L.DomEvent\n            .on(document, 'mousemove', this._handleMouseDrag, this)\n            .on(document, 'mouseup', this._handleMouseUp, this);\n    },\n\n    _handleMouseUp: function(e) {\n        L.DomEvent.stop(e); // L.DomEvent.stopPropagation(e);\n        this.dragging = false;\n\n        L.DomEvent\n            .off(document, 'mousemove', this._handleMouseDrag, this)\n            .off(document, 'mouseup', this._handleMouseUp, this);\n    },\n\n    _handleMouseDrag: function(e) {\n        if (!this.dragging) { return; }\n        var deltaX = e.clientX - this.dragstartX;\n        this._map.setBearing(deltaX);\n    },\n\n    _cycleState: function(ev) {\n        var map = this._map;\n\n        if (!map) { return; }\n\n        if (!map.touchRotate.enabled() && !map.compassBearing.enabled()) {\n            // Go from disabled to touch\n            map.touchRotate.enable();\n\n            // console.log('state is now: touch rotate');\n        } else {\n\n            if (!map.compassBearing.enabled()) {\n                // Go from touch to compass\n                map.touchRotate.disable();\n                map.compassBearing.enable();\n\n                // console.log('state is now: compass');\n\n                // It is possible that compass is not supported. If so,\n                // the hangler will automatically go from compass to disabled.\n            } else {\n                // Go from compass to disabled\n                map.compassBearing.disable();\n\n                // console.log('state is now: locked');\n\n                map.setBearing(0);\n                if (this.options.closeOnZeroBearing) {\n                    map.touchRotate.enable();\n                }\n            }\n        }\n        this._restyle();\n    },\n\n    _restyle: function() {\n        if (this._map.options.rotate) {\n            var map = this._map;\n            var bearing = map.getBearing();\n            if (this.options.closeOnZeroBearing && bearing) {\n                this._container.style.display = 'block';\n            }\n\n            var cssTransform = 'rotate(' + bearing + 'deg)';\n            this._arrow.style.transform = cssTransform;\n\n            if (map.compassBearing.enabled()) {\n                this._link.style.backgroundColor = 'orange';\n            } else if (map.touchRotate.enabled()) {\n                this._link.style.backgroundColor = null;\n            } else {\n                this._link.style.backgroundColor = 'grey';\n                if (this.options.closeOnZeroBearing && map.getBearing() === 0) {\n                    this._container.style.display = 'none';\n                }\n            }\n        } else {\n            L.DomUtil.addClass(this._link, 'leaflet-disabled');\n        }\n    },\n\n});\n\nL.control.rotate = function(options) {\n    return new L.Control.Rotate(options);\n};\n\nL.Map.mergeOptions({\n    rotateControl: true,\n});\n\nL.Map.addInitHook(function() {\n    if (this.options.rotateControl) {\n        var options = typeof this.options.rotateControl === 'object' ? this.options.rotateControl : {};\n        this.rotateControl = L.control.rotate(options);\n        this.addControl(this.rotateControl);\n    }\n});\n"],"names":["domUtilProto","L","extend","DomUtil","setTransform","el","offset","scale","bearing","pivot","pos","Point","_round","call","this","rotateFrom","style","TRANSFORM","x","y","setPosition","point","_leaflet_pos","Browser","any3d","undefined","left","top","DEG_TO_RAD","Math","PI","RAD_TO_DEG","Draggable","include","updateMapBearing","mapBearing","_mapBearing","prototype","rotate","theta","sinTheta","sin","cosTheta","cos","cx","cy","divOverlayProto","DivOverlay","getEvents","_updatePosition","_map","latLngToLayerPoint","_latlng","options","anchor","_getAnchor","_zoomAnimated","_rotate","rotatedPointToMapPanePoint","_container","add","bottom","_containerBottom","_containerLeft","round","_containerWidth","popupProto","Popup","_animateZoom","e","_latLngToNewLayerPoint","zoom","center","_adjustPan","autoPan","_panAnim","_inProgress","_autopanning","map","marginBottom","parseInt","getStyle","containerHeight","offsetHeight","containerWidth","layerPos","_add","getPosition","containerPos","_getMapPanePos","padding","autoPanPadding","paddingTL","autoPanPaddingTopLeft","paddingBR","autoPanPaddingBottomRight","size","getSize","dx","dy","keepInView","fire","panBy","tooltipProto","Tooltip","_setPosition","Icon","markerDragProto","_setIconStyles","img","name","sizeOption","shadowAnchor","iconAnchor","divideBy","className","marginLeft","marginTop","width","height","MarkerDrag","_onDragStart","_marker","_draggable","_bearing","_onDrag","marker","rotated_marker","rotation","rotateWithView","shadow","_shadow","iconPos","_icon","mapPanePointToRotatedPoint","latlng","layerPointToLatLng","oldLatLng","_oldLatLng","setLatLng","_onDragEnd","update","markerProto","Marker","mergeOptions","onAdd","on","_initInteraction","ret","dragging","enabled","Object","getPrototypeOf","assign","bind","disable","enable","_setPos","_zIndex","zIndexOffset","_resetZIndex","_panOnFocus","_updateZIndex","zIndex","setRotation","gridLayerProto","GridLayer","events","updateWhenIdle","_onRotate","Util","throttle","_onMoveEnd","updateInterval","_getTiledPixelBounds","mapZoom","_animatingZoom","max","_animateToZoom","getZoom","getZoomScale","_tileZoom","pixelCenter","project","floor","halfSize","Bounds","containerPointToLayerPoint","subtract","canvasProto","Canvas","_redraw","onRemove","off","_update","rendererProto","Renderer","_updateTransform","_zoom","_topLeft","p","padMin","multiplyBy","padMax","clip","_bounds","min","_center","getCenter","svgProto","SVG","mapProto","Map","initialize","id","setBearing","_getRotatePanePos","getBounds","topleft","topright","bottomright","bottomleft","LatLngBounds","layerPointToContainerPoint","rotatePanePos","_pivot","clone","_rotatePanePos","_rotatePane","getBearing","_initPanes","panes","_panes","_paneRenderers","_mapPane","createPane","_norotatePane","markerZoomAnimation","addClass","markerPane","shadowPane","_subtract","_getCenterOffset","centerOffset","_getNewPixelOrigin","viewHalf","_divideBy","_handleGeolocationResponse","_leaflet_id","lat","coords","latitude","lng","longitude","hdg","heading","LatLng","bounds","toBounds","accuracy","_locateOptions","setView","getBoundsZoom","maxZoom","data","timestamp","i","CompassBearing","Handler","window","DeviceOrientationEvent","_capable","_throttled","_onDeviceOrientation","addHooks","DomEvent","removeHooks","event","alpha","orientation","addInitHook","trackContainerMutation","ContainerMutation","mutation","_observer","MutationObserver","_onMutation","observe","getContainer","childList","attributes","characterData","subtree","attributeFilter","disconnect","invalidateSize","bounceAtZoomLimits","TouchGestures","touchRotate","touchZoom","_onTouchStart","touches","length","_zooming","_rotating","p1","mouseEventToContainerPoint","p2","vector","_centerPoint","_startLatLng","containerPointToLatLng","_pinchStartLatLng","_startDist","distanceTo","_startZoom","_startTheta","atan","_startBearing","_moved","stop","document","_onTouchMove","_onTouchEnd","preventDefault","delta","bearingDelta","getScaleZoom","getMinZoom","getMaxZoom","_limitZoom","unproject","_moveStart","cancelAnimFrame","_animRequest","moveFn","_move","pinch","requestAnimFrame","zoomAnimation","snapZoom","_resetView","TouchRotate","touchGestures","shiftKeyRotate","ShiftKeyRotate","_handleShiftScroll","shiftKey","scrollWheelZoom","sign","deltaY","touch","android23","TouchZoom","removeClass","Control","Rotate","position","closeOnZeroBearing","_unthrottledOnDeviceOrientation","container","create","arrow","_arrow","backgroundImage","cursor","display","backgroundRepeat","backgroundPosition","link","_link","appendChild","href","title","stopPropagation","_handleMouseDown","_cycleState","_refocusOnMap","_restyle","_follow","_canFollow","dragstartX","pageX","dragstartY","pageY","_handleMouseDrag","_handleMouseUp","deltaX","clientX","ev","compassBearing","cssTransform","transform","backgroundColor","control","rotateControl","addControl"],"mappings":"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"}